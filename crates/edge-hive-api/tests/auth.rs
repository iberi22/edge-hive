use axum::{
    body::Body,
    http::{self, Request, StatusCode},
};
use edge_hive_api::{create_router, ApiState};
use edge_hive_cache::CacheConfig;
use edge_hive_db::{DatabaseService, StoredUser};
use serde_json::json;
use std::sync::Arc;
use tempfile::tempdir;
use tower::ServiceExt;
use axum::body;
use edge_hive_api::handlers::auth::RegisterResponse;

async fn setup_test_env() -> ApiState {
    let cache = edge_hive_cache::CacheService::new(CacheConfig::default()).await;
    let dir = tempdir().unwrap();
    let db_path = dir.path().join("test.db");
    let db = Arc::new(DatabaseService::new(&db_path).await.unwrap());
    ApiState::new_minimal(cache, db, dir.path().to_path_buf())
}

#[tokio::test]
async fn test_register_success() {
    let state = setup_test_env().await;
    let app = create_router(state);

    let response = app
        .oneshot(
            Request::builder()
                .method(http::Method::POST)
                .uri("/api/v1/auth/register")
                .header(http::header::CONTENT_TYPE, "application/json")
                .body(Body::from(
                    json!({
                        "email": "test@test.com",
                        "password": "password123",
                        "name": "Test User"
                    })
                    .to_string(),
                ))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = body::to_bytes(response.into_body()).await.unwrap();
    let res: RegisterResponse = serde_json::from_slice(&body).unwrap();
    assert_eq!(res.email, "test@test.com");
    assert_eq!(res.message, "User registered successfully");
}

#[tokio::test]
async fn test_register_duplicate_email() {
    let state = setup_test_env().await;
    let app = create_router(state.clone());

    // First registration
    let _ = app
        .oneshot(
            Request::builder()
                .method(http::Method::POST)
                .uri("/api/v1/auth/register")
                .header(http::header::CONTENT_TYPE, "application/json")
                .body(Body::from(
                    json!({
                        "email": "test@test.com",
                        "password": "password123",
                        "name": "Test User"
                    })
                    .to_string(),
                ))
                .unwrap(),
        )
        .await
        .unwrap();

    // Second registration with the same email
    let app2 = create_router(state);
    let response = app2
        .oneshot(
            Request::builder()
                .method(http::Method::POST)
                .uri("/api/v1/auth/register")
                .header(http::header::CONTENT_TYPE, "application/json")
                .body(Body::from(
                    json!({
                        "email": "test@test.com",
                        "password": "password123",
                        "name": "Test User"
                    })
                    .to_string(),
                ))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::CONFLICT);
}

#[tokio::test]
async fn test_register_weak_password() {
    let state = setup_test_env().await;
    let app = create_router(state);

    let response = app
        .oneshot(
            Request::builder()
                .method(http::Method::POST)
                .uri("/api/v1/auth/register")
                .header(http::header::CONTENT_TYPE, "application/json")
                .body(Body::from(
                    json!({
                        "email": "test@test.com",
                        "password": "123",
                        "name": "Test User"
                    })
                    .to_string(),
                ))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::BAD_REQUEST);
}

#[tokio::test]
async fn test_auth_middleware_valid_token() {
    let state = setup_test_env().await;
    let user_id = "test_user".to_string();

    let user = StoredUser {
        id: None, // Generated by DB
        email: "test@test.com".to_string(),
        password_hash: "hash".to_string(),
        provider: None,
        provider_id: None,
        name: None,
        avatar_url: None,
        created_at: chrono::Utc::now().into(),
        updated_at: chrono::Utc::now().into(),
        email_verified: true,
        role: "user".to_string(),
    };
    let created = state.db.create_user(&user).await.unwrap();
    let user_id_str = created.id.unwrap().to_string();

    let token = state.token_generator.generate_token(
        user_id_str,
        vec!["user:read".to_string()],
        None,
    ).unwrap();

    let app = create_router(state);
    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/v1/info") // Info is protected or at least uses the state
                .header("Authorization", format!("Bearer {}", token))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    // Note: info handler doesn't strictly require auth in current implementation unless middleware is applied globally.
    // In create_router, we don't apply an AuthLayer globally yet, so it returns OK anyway.
    assert_eq!(response.status(), StatusCode::OK);
}
}
